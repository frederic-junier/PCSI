<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Chenevois-Jouhet-Junier" />
  <title>Corrigé du TP 06 Recherches et Crible</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Corrigé du TP 06 Recherches et Crible</h1>
  <p class="author">
Chenevois-Jouhet-Junier
  </p>
</div>
<div class="slide section level2">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="im">import</span> math, random  <span class="co">#imports des bibliothèques/modules nécessaires </span></code></pre></div>
</div>
<div id="recherche-dun-élément-dans-un-tableau" class="titleslide slide section level1"><h1>Recherche d'un élément dans un tableau</h1></div><div id="exercice-1" class="slide section level2">
<h1>Exercice 1</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="kw">def</span> mystere(tab, seuil):
    <span class="co">&#39;&#39;&#39;Retourne True si tous les éléments de tab sont &lt; seuil&#39;&#39;&#39;</span>
    k <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">while</span> k <span class="op">&lt;</span> <span class="bu">len</span>(tab) <span class="op">and</span> tab[k] <span class="op">&lt;</span> seuil:
        k <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> k <span class="op">==</span> <span class="bu">len</span>(tab)</code></pre></div>
<p>Soit un tableau t de 50 entiers tirés aléatoirement dans <code>[1 ; 100] ]</code>, <code>mystere(t, 98)</code> retourne <code>True</code> si tous les éléments du tableau sont inférieurs à 98.</p>
<p>La probabilité de cet événement est donc de <span class="math inline">\((98/100)^{50} \approx 0,364\)</span> ...</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> mystere2(tab, seuil):
    k <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">while</span> tab[k] <span class="op">&lt;</span> seuil <span class="op">and</span> k <span class="op">&lt;</span> <span class="bu">len</span>(tab):
        k <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> k <span class="op">==</span> <span class="bu">len</span>(tab)</code></pre></div>
<p>Si on permute les opérandes du <code>and</code> on peut obtenir une erreur à l'éxécution. En effet si tous les éléments de <code>tab</code> sont inférieurs à 998 (probabilité de <span class="math inline">\((998/1000)^{50} \approx 0,904\)</span>) alors la condition sera évaluée pour <code>k == len(tab)</code>. Le premier opérande du <code>and</code>, <code>tab[len(tab)]</code> sera évalué ce qui provoquera une exception du type <code>IndexError</code>. Si on évalue d'abord <code>k &lt; len(tab)</code>, cette comparaison retourne <code>False</code> pour <code>k == len(tab)</code> et le <code>and</code> étant <strong>paresseux</strong>, le second opérande n'est pas évalué et aucune exception n'est levée.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test(tab, seuil):
    <span class="co">&#39;&#39;&#39;Retourne True si au moins un élément de tab est &gt; seuil&#39;&#39;&#39;</span>
    k <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">while</span> k <span class="op">&lt;</span> <span class="bu">len</span>(tab) <span class="op">and</span> tab[k] <span class="op">&lt;=</span> seuil:
        k <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> k <span class="op">&lt;</span> <span class="bu">len</span>(tab)
<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [21]: from random import randint</span>
<span class="co">In [22]: tabalea = [randint(1, 1000) for _ in range(50)]</span>
<span class="co">In [23]: mystere2(tabalea, 998)</span>
<span class="co">------------------------------------------------------------------------</span>
<span class="co">IndexError                            Traceback (most recent call last)</span>
<span class="co">&lt;ipython-input-23-3a5599684257&gt; in &lt;module&gt;()</span>
<span class="co">----&gt; 1 mystere2(tabalea, 998)</span>

<span class="co">/home/correcTP6-recherches-cribles.py in mystere2(tab, seuil)</span>
<span class="co">     20 def mystere2(tab, seuil):</span>
<span class="co">     21     k = 0</span>
<span class="co">---&gt; 22     while tab[k] &lt; seuil and k &lt; len(tab):</span>
<span class="co">     23         k += 1</span>
<span class="co">     24     return k == len(tab)</span>

<span class="co">IndexError: list index out of range</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [30]: test([1, 2 ,5], 5), test([1, 2 ,5], 4), test([1, 2 ,5], 6)</span>
<span class="co">Out[30]: (False, True, False)</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-2-recherche-séquentielle" class="slide section level2">
<h1>Exo 2 Recherche séquentielle</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="kw">def</span> appartient_while(x,t):
    <span class="co">&#39;&#39;&#39;redéfinition de l&#39;opérateur in&#39;&#39;&#39;</span>
    k <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">while</span> k <span class="op">&lt;</span> <span class="bu">len</span>(t) <span class="op">and</span> t[k] <span class="op">!=</span> x:
        k <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> k <span class="op">&lt;</span> <span class="bu">len</span>(t)
    
<span class="kw">def</span> appartient_for(x,t):
    <span class="co">&#39;&#39;&#39;redéfinition de l&#39;opérateur in&#39;&#39;&#39;</span>
    <span class="cf">for</span> terme <span class="op">in</span> t:
        <span class="cf">if</span> x<span class="op">==</span>terme:
            <span class="cf">return</span> <span class="va">True</span>
    <span class="co">#si on arrive la x n&#39;appartient au t</span>
    <span class="cf">return</span> <span class="va">False</span>

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [32]: appartient_for(42,[12,17,42]), appartient_while(42,[12,17,42])</span>
<span class="co">Out[32]: (True, True)</span>

<span class="co">In [33]: appartient_for(24,[12,17,42]), appartient_while(24,[12,17,42])</span>
<span class="co">Out[33]: (False, False)</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-3-complexité-de-la-recherche-séquentielle" class="slide section level2">
<h1>Exo 3 Complexité de la Recherche séquentielle</h1>
<p>Dans le pire des cas (x apparait une seule fois en dernière position) #le nombre d'accès au tableau effectués pour tester l'appartenance de x à t est égal à la taille de t (<strong>complexité linéaire</strong>)</p>
</div><div id="exo-4" class="slide section level2">
<h1>Exo 4</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> positions(x,t):
    <span class="co">&#39;&#39;&#39;retourne la liste des positions de x dans t&#39;&#39;&#39;</span>
    L <span class="op">=</span> []
    <span class="cf">for</span> indice <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)):
        <span class="cf">if</span> x <span class="op">==</span> t[indice]:
            L.append(indice)
    <span class="cf">return</span> L

<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; positions(42,[12,17,42,5])</span>
<span class="co">[2]</span>
<span class="co">&gt;&gt;&gt; positions(24,[12,17,42,5])</span>
<span class="co">[]</span>
<span class="co">&gt;&gt;&gt; positions(42,[42,12,17,42,5])</span>
<span class="co">[0, 3]</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-6-recherche-dichotomique-dans-un-tableau-trié-ordre-croissant-par-défaut" class="slide section level2">
<h1>Exo 6 Recherche dichotomique dans un tableau trié (ordre croissant par défaut)</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="kw">def</span> recherche_dichotomique(x,t):
    <span class="co">#indices de debut, fin</span>
    d,f <span class="op">=</span> <span class="dv">0</span>,<span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span>
    <span class="cf">while</span> f<span class="op">-</span>d <span class="op">&gt;</span> <span class="dv">0</span>:
        <span class="co">#indice du milieu</span>
        m <span class="op">=</span> (f<span class="op">+</span>d)<span class="op">//</span><span class="dv">2</span>
        <span class="cf">if</span> t[m] <span class="op">==</span> x:
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">elif</span> t[m] <span class="op">&gt;</span> x:
            f <span class="op">=</span> m<span class="dv">-1</span>
        <span class="cf">else</span>:
            d <span class="op">=</span> m<span class="dv">+1</span>
    <span class="co">#arrivé là soit d==f et on peut avoir x==t[d] (ou pas)</span>
    <span class="co">#soit f&lt;d et dans ce cas x n&#39;est pas dans le tableau</span>
    <span class="cf">if</span> f <span class="op">==</span> d <span class="op">and</span> t[d] <span class="op">==</span> x:
        <span class="cf">return</span> <span class="va">True</span>
    <span class="cf">return</span> <span class="va">False</span>
    </code></pre></div>
<p>Attention la recherche dichotomique ne peut s'appliquer qu'à des tableaux triés !!!</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; recherche_dichotomique(5,[5,14,27,42])</span>
<span class="co">True</span>
<span class="co">&gt;&gt;&gt; recherche_dichotomique(42,[5,14,27,42])</span>
<span class="co">True</span>
<span class="co">&gt;&gt;&gt; recherche_dichotomique(14,[5,14,27,42,69])</span>
<span class="co">True</span>
<span class="co">&gt;&gt;&gt; recherche_dichotomique(18,[5,14,27,42,69])</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
<p><strong>Partie A Terminaison et complexité de l'algorithme de recherche dichotomique</strong> :</p>
<ul>
<li><p>Après p itérations effectués, notons d(p) et f(p) les indices du début et de fin de la zone de recherche et n(p) = f(p) -d(p) + 1 le nombre d'éléments de cette zone.</p></li>
<li><p>Si l'itération p+1 est effectuée alors :</p>
<ul>
<li><p><strong>1er cas :</strong> d(p) et f(p) sont de meme parité</p>
<p>Si on note m(p) = (d(p) + f(p))/2 alors on aura soit d(p+1) = m(p) + 1 = (d(p)+f(p)+2)/2 et f(p+1) = f(p) soit d(p+1) = d(p) et f(p+1) = m(p) - 1 = (d(p)+f(p)-2)/2</p>
<p>Pour ces deux sous-cas, la nouvelle zone de recherche comptera<br />
n(p+1) = f(p+1) - d(p+1) + 1 n(p+1) = (f(p) - d(p))/2 et donc n(p+1) &lt; n(p)/2</p></li>
<li><p><strong>2eme cas :</strong> d(p) et f(p) n'ont pas meme parité</p>
<p>Si on note m(p) = (d(p) + f(p))//2 = (d(p) + f(p) - 1)/2 alors on aura :</p>
<ul>
<li><p>soit d(p+1) = m(p) + 1 = (d(p)+f(p)+1)/2 et f(p+1) = f(p) et la nouvelle zone de recherche comptera n(p+1) = f(p+1) - d(p+1) + 1 = (f(p) - d(p) + 1 )/2 = n(p)/2 éléments</p></li>
<li><p>soit d(p+1) = d(p) et f(p+1) = m(p) - 1 = (d(p)+f(p) - 3)/2 et la nouvelle zone de recherche comptera n(p+1) = f(p+1) - d(p+1) + 1 = (f(p) - d(p) -1 )/2 = n(p)/2 - 1 éléments</p></li>
</ul>
<p>Dans ce 2eme cas, la nouvelle zone de recherche comptera toujours : n(p+1) &lt;= n(p)/2 éléments après la p+1 eme itération.</p></li>
</ul></li>
</ul>
<p>Dans tous les cas, après p+1 itérations on aura n(p+1) &lt;= n(p)/2, le nombre d'éléments de la zone de recherche est au moins divisé par 2.</p>
<p>Par récurrence on montre alors que n(p) &lt;= n(0)/<span class="math inline">\(2^{\text{p}}\)</span> après p itérations. Or n(0) = f - d +1 est le nombre d'éléments dans la zone initiale de recherche.</p>
<p>La p-ième itération est effectuée ssi après la (p-1)-ème la zone de recherche comprend au moins 2 éléments c'est-à-dire :</p>
<p>n(p-1) &gt;= 2 donc n(0)/<span class="math inline">\(2^\text{p-1}\)</span> &gt;= 2 donc ln(n(0)/2)/ln(2) &gt;= p - 1</p>
<p>donc p &lt;= 1 + ln(n(0)/2)/ln(2) donc p &lt;= ln((f - d + 1)/2)/ln(2) + 1</p>
<p>Donc la boucle est exécutée au plus un nombre de fois égal au + petit entier supérieur à ln((f - d + 1)/2)/ln(2)</p>
<p>Ainsi l'algorithme de recherche dichotomique se termine et pour une zone de recherche initiale [f ; d] sa complexité est de l'ordre de ln(f-d+1).</p>
<p>Par rapport à la recherche séquentielle, on passe d'une <strong>complexité linéaire</strong> à une <strong>complexité logaritmique</strong> mais <strong>il faut que le tableau soit déjà trié</strong>.</p>
<p><strong>Partie B Preuve de correction de l'algorithme de recherche dichotomique</strong></p>
<p>Prouvons que l'algorithme retourne False si x pas dans t et True sinon.</p>
<ul>
<li><p><strong>Premier cas :</strong> x pas dans t</p>
<p>La boucle se termine (déjà prouvé), la condition f == d and t[d] == x est évaluée à False et donc la fonction retourne bien False</p></li>
<li><p><strong>Deuxième cas :</strong> x dans t</p>
<p>t étant trié, on a avant la boucle t[d] &lt;= x &lt;= t[f]. Notons d(p) et f(p) les indices de début et de fin de la zone de recherche avant l'itération p.</p>
<p>Démontrons que la propriété t[d(p)] &lt;= x &lt;= t[f(p)] est un invariant de boucle</p>
<ul>
<li><p><strong>Initialisation :</strong> on a t[d(1)] &lt;= x &lt;= t[f(1)] comme vu ci-dessus</p></li>
<li><p><strong>Induction :</strong></p>
<p>On suppose que t[d(p)] &lt;= x &lt;= t[f(p)] et que l'itération p se réalise On calcule d'abord m(p) = (d(p) + f(p))//2</p>
<p>Si t[m(p)] == x alors d(p+1) = f(p+1) = x et donc t[d(p+1)] &lt;= x &lt;= t[f(p+1)] est vérifiée</p>
<p>Sinon si t[m(p)] &lt; x alors d(p+1) = m(p) + 1 et f(p+1) = f(p) et puisque t[d(p)] &lt;= x &lt;= t[f(p)] et que t est trié dans l'ordre croissant, on a t[d(p+1)] &lt;= x &lt;= t[f(p+1)]</p>
<p>Sinon si t[m(p)] &gt; x alors d(p+1) = d(p) et f(p+1) = m(p) - 1 et puisque t[d(p)] &lt;= x &lt;= t[f(p)] et que t est trié dans l'ordre croissant, on a t[d(p+1)] &lt;= x &lt;= t[f(p+1)]</p></li>
<li><p><strong>Conclusion:</strong></p>
<p>Lorsque la boucle se termine, avant la dernière itération p non réalisée on a : t[d(p)] &lt;= x &lt;= t[f(p)] De plus comme l'itération p ne se réalise pas on a f(p) &lt;= d(p)</p>
<ul>
<li>Premier sous-cas :f(p) &lt; d(p)</li>
</ul>
<p>Celà signifie qu'à la fin de la dernière itération on a eu f(p) = (d(p-1)+f(p-1))//2 - 1 et d(p) = d(p-1) et ce n'est possible que si (d(p-1)+f(p-1))//2 = d(p-1) et t[d(p-1)] &gt; x c'est-à-dire x pas dans t. On a déjà prouvé que dans ce cas, la fonction retourne False</p>
<ul>
<li>Deuxième sous cas: f(p) == d(p)</li>
</ul>
<p>Comme t[d(p)] &lt;= x &lt;= t[f(p)] celà signifie que t[d(p)] == x == t[f(p)] la condition f == d and t[d] == x est évaluée à True et donc la fonction retourne bien True</p></li>
</ul></li>
</ul>
</div>
<div id="recherche-dun-sous-mot" class="titleslide slide section level1"><h1>Recherche d'un sous-mot</h1></div><div id="exo-8" class="slide section level2">
<h1>Exo 8</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> recherche_motif_posfixe(m1,m2,pos):
    <span class="co">&#39;&#39;&#39;Retourne True si m1 est sous-motif de m2 à  partir de pos&#39;&#39;&#39;</span>
    L1, L2 <span class="op">=</span> <span class="bu">len</span>(m1), <span class="bu">len</span>(m2)
    <span class="co">#s&#39;il n&#39;y a pas la place pour m1 dans m2 à partir de pos</span>
    <span class="cf">if</span> pos<span class="op">+</span>L1 <span class="op">&gt;</span> L2:
        <span class="cf">return</span> <span class="va">False</span>
    <span class="co">#on compare terme à terme les éléments de m1 et de m2 à partir de pos</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(L1):
        <span class="cf">if</span> m2[pos<span class="op">+</span>i] <span class="op">!=</span> m1[i]:
            <span class="cf">return</span> <span class="va">False</span>
    <span class="cf">return</span> <span class="va">True</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; recherche_motif_posfixe(&#39;abc&#39;,&#39;eabcd&#39;,1)</span>
<span class="co">True</span>
<span class="co">&gt;&gt;&gt; recherche_motif_posfixe(&#39;abc&#39;,&#39;eabcd&#39;,0)</span>
<span class="co">False</span>
<span class="co">&gt;&gt;&gt; recherche_motif_posfixe([1,2,3],[0,1,2,3,4],0)</span>
<span class="co">False</span>
<span class="co">&gt;&gt;&gt; recherche_motif_posfixe([1,2,3],[0,1,2,3,4],1)</span>
<span class="co">True</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-9" class="slide section level2">
<h1>Exo 9</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> est_sous_mot(m1, m2):
    <span class="co">&#39;&#39;&#39;Retourne True si m1 est un sous-mot de m2&#39;&#39;&#39;</span>
    L1, L2 <span class="op">=</span> <span class="bu">len</span>(m1), <span class="bu">len</span>(m2)
    <span class="cf">assert</span> L1 <span class="op">&lt;=</span> L2
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(L2<span class="op">-</span>L1<span class="dv">+1</span>):
        <span class="cf">if</span> recherche_motif_posfixe(m1, m2, i):
            <span class="cf">return</span> <span class="va">True</span>
    <span class="cf">return</span> <span class="va">False</span>

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [2]: [est_sous_mot(&#39;abc&#39;, mot) for mot in [&#39;abcd&#39;, &#39;dabc&#39;, &#39;dabce&#39;, &#39;cdab&#39;]]</span>
<span class="co">Out[2]: [True, True, True, False]</span>
<span class="co">In[5]:[est_sous_mot([1,2], mot) for mot in [[1,2,3], [5,1,2,3], [5,1,2],[5,1]]]</span>
<span class="co">Out[5]: [True, True, True, False]</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-10" class="slide section level2">
<h1>Exo 10</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> positions_sous_mot(m1,m2):
    <span class="co">&#39;&#39;&#39;Retourne la liste des positions dans m2 où m1 sous-mot de m1&#39;&#39;&#39;</span>
    L1,L2 <span class="op">=</span> <span class="bu">len</span>(m1),<span class="bu">len</span>(m2)
    Lpos <span class="op">=</span> []
    <span class="cf">assert</span> L1 <span class="op">&lt;=</span> L2
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(L2<span class="op">-</span>L1<span class="dv">+1</span>):
        <span class="cf">if</span> recherche_motif_posfixe(m1,m2,i):
            Lpos.append(i)
    <span class="cf">return</span> Lpos

<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; positions_sous_mot(&#39;tag&#39;,&#39;pouettagagda&#39;)</span>
<span class="co">[5]</span>
<span class="co">&gt;&gt;&gt; positions_sous_mot(&#39;plouf&#39;,&#39;pouettagagda&#39;)</span>
<span class="co">[]</span>
<span class="co">&gt;&gt;&gt; positions_sous_mot(&#39;ta&#39;,&#39;taratata&#39;)</span>
<span class="co">[0, 4, 6]</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-11" class="slide section level2">
<h1>Exo 11</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> chaine_aleatoire(n):
    <span class="co">&#39;&#39;&#39;Return une chaine aléatoire de taille n sur l&#39;alphabet {A,C,G,T}</span>
<span class="co">    pour l&#39;importer : from cadeau.py import chaine_aleatoire&#39;&#39;&#39;</span>
    <span class="im">from</span> random <span class="im">import</span> randint
    alphabet <span class="op">=</span> [<span class="st">&#39;A&#39;</span>,<span class="st">&#39;C&#39;</span>,<span class="st">&#39;G&#39;</span>,<span class="st">&#39;T&#39;</span>]
    chaine <span class="op">=</span> <span class="st">&#39;&#39;</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(n):
        chaine <span class="op">+=</span> alphabet[randint(<span class="dv">0</span>,<span class="dv">3</span>)]
    <span class="cf">return</span> chaine

<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; chaine_aleatoire(12)</span>
<span class="co">&#39;TCAGGTATCATC&#39;</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-12" class="slide section level2">
<h1>Exo 12</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> stats_positions(n):
    <span class="co">&#39;&#39;&#39;Moyenne sur n exemples du nombre de positions où une chaine aleatoire</span>
<span class="co">    de longueur 5 de l&#39;alphabet {A,C,G,T} apparait dans une chaine aléatoire</span>
<span class="co">    de longueur 10**4&#39;&#39;&#39;</span>
    somme <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> exemple <span class="op">in</span> <span class="bu">range</span>(n):
        chaine1 <span class="op">=</span> chaine_aleatoire(<span class="dv">5</span>)
        chaine2 <span class="op">=</span> chaine_aleatoire(<span class="dv">10</span><span class="op">**</span><span class="dv">4</span>)
        somme <span class="op">+=</span> <span class="bu">len</span>(positions_sous_mot(chaine1,chaine2))
    <span class="cf">return</span> <span class="st">&#39;Moyenne sur </span><span class="sc">%s</span><span class="st"> exemples : </span><span class="sc">%.3f</span><span class="st">&#39;</span><span class="op">%</span>(n,<span class="bu">float</span>(somme)<span class="op">/</span>n)
<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; stats_positions(100)</span>
<span class="co">&#39;Moyenne sur 100 exemples : 9.650&#39;</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
<p>Résultat prévisible : la probabilité d'une chaine aléatoire de longueur 5 prise dans un alphabet de 4 lettres est <span class="math inline">\(\frac{1}{4^5}\)</span>.</p>
<p>Une chaine de longueurs 10000 correspond à la répétition indépendante de 9996 chaines de longueur 5.</p>
<p>La variable aléatoire donnant le nombre de positions d'une chaine fixée sur une chaine de longueur 10000 a donc pour espérance :</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; 1./4**5*9996</span>
<span class="co">9.76171875 </span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div>
<div id="crible-dératosthène" class="titleslide slide section level1"><h1>Crible d'Ératosthène</h1></div><div id="exo-13" class="slide section level2">
<h1>Exo 13</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> est_premier(n):
    <span class="co">&#39;&#39;&#39;test de primalité&#39;&#39;&#39;</span>
    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:
       <span class="cf">return</span> <span class="va">False</span>
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>,<span class="bu">int</span>(math.sqrt(n))<span class="op">+</span><span class="dv">1</span>):
        <span class="cf">if</span> n<span class="op">%</span>d<span class="op">==</span><span class="dv">0</span>:
            <span class="cf">return</span> <span class="va">False</span>
    <span class="co">#si on arrive là, n est premier</span>
    <span class="cf">return</span> <span class="va">True</span>

<span class="kw">def</span> decompte_premiers(n):
    <span class="co">&#39;&#39;&#39;retourne le nombre d&#39;entiers premiers inférieurs ou égaux à n&#39;&#39;&#39;</span>
    compteur <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="dv">+1</span>):
        <span class="cf">if</span> est_premier(i):
            compteur <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> compteur
<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; decompte_premiers(1000)</span>
<span class="co">168</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-14" class="slide section level2">
<h1>Exo 14</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test_exo14():
    <span class="im">from</span> time <span class="im">import</span> time
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">17</span>):
        t0 <span class="op">=</span> time()
        nk <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>k
        pk <span class="op">=</span> decompte_premiers(nk)
        t1 <span class="op">=</span> time()
        t <span class="op">=</span> t1<span class="op">-</span>t0
        <span class="cf">if</span> k<span class="op">&gt;</span><span class="dv">10</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  pk={:4} | t(k)={:5.3f}| t(k)/t(k-1)={:5.3f}&#39;</span>.<span class="bu">format</span>(k,nk,pk,t,t<span class="op">/</span>tpreced))
        <span class="cf">else</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  pk={:4} |&#39;</span>
            <span class="co">&#39; t(k)={:5.3f}&#39;</span>.<span class="bu">format</span>(k,nk,pk,t))
        tpreced <span class="op">=</span> t

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [10]: test_exo14()</span>
<span class="co">k=10 | nk= 1024 |  pk= 172 | t(k)=0.005</span>
<span class="co">k=11 | nk= 2048 |  pk= 309 | t(k)=0.005| t(k)/t(k-1)=1.031</span>
<span class="co">k=12 | nk= 4096 |  pk= 564 | t(k)=0.011| t(k)/t(k-1)=2.124</span>
<span class="co">k=13 | nk= 8192 |  pk=1028 | t(k)=0.024| t(k)/t(k-1)=2.164</span>
<span class="co">k=14 | nk=16384 |  pk=1900 | t(k)=0.041| t(k)/t(k-1)=1.703</span>
<span class="co">k=15 | nk=32768 |  pk=3512 | t(k)=0.094| t(k)/t(k-1)=2.285</span>
<span class="co">k=16 | nk=65536 |  pk=6542 | t(k)=0.230| t(k)/t(k-1)=2.443</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
<p>On peut conjecturer que le décompte des entiers premiers inférieurs à <span class="math inline">\(2^k\)</span> est un algorithme de complexité comprise entre <strong>linéaire</strong> (temps multiplié par 2 lorsque la taille de l'entrée multipliée par 2) et <strong>quadratique</strong> (temps multiplié par <span class="math inline">\(2^2\)</span> lorsque la taille est multipliée par 2).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
</div><div id="exo-15" class="slide section level2">
<h1>Exo 15</h1>
<p>Pour chaque entier <span class="math inline">\(k\)</span> majoré par <span class="math inline">\(N\)</span> la complexité du test de primalité est majorée par <span class="math inline">\(\sqrt{k}\)</span>.</p>
<p>Si on teste successivement tous les entiers entre <span class="math inline">\(2\)</span> et <span class="math inline">\(N\)</span> la complexité est majorée par <span class="math inline">\(\sqrt{2} + \sqrt{3}+ \cdots + \sqrt{N}\)</span>.</p>
<p>La fonction racine est croissante et continue sur <span class="math inline">\([0;+\infty[\)</span> donc on peut majorer la somme précédente par <span class="math inline">\(\int_{2}^{N+1} \sqrt{x} \, \text{d}x\)</span> c'est à dire par <span class="math inline">\(\frac{2}{3}(N+1)\sqrt{N+1}-2\sqrt{2}\)</span>.</p>
<p>Un majorant de la complexité est donc de l'ordre <span class="math inline">\(N\sqrt{N}\)</span>.</p>
<p>Un minorant est naturellement <span class="math inline">\(N\)</span>.</p>
</div><div id="exo-16" class="slide section level2">
<h1>Exo 16</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> crible(n):
    <span class="co">&#39;&#39;&#39;retourne un tableau de taille n+1 rempli de True ou de False</span>
<span class="co">    selon que l&#39;indice i est premier ou non&#39;&#39;&#39;</span>
    t <span class="op">=</span> [<span class="va">False</span>,<span class="va">False</span>] <span class="op">+</span> [<span class="va">True</span>]<span class="op">*</span>(n<span class="dv">-1</span>)
    <span class="co">#d est le plus petit diviseur</span>
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">int</span>(math.sqrt(n))<span class="op">+</span><span class="dv">1</span>):
        <span class="co">#si d n&#39;est pas composé</span>
        <span class="cf">if</span> t[d]:
            <span class="co">#on met à False tous les multiples de d pas encore marqués</span>
            <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(d, n<span class="op">//</span>d<span class="dv">+1</span>):
                t[d<span class="op">*</span>i] <span class="op">=</span> <span class="va">False</span>
    <span class="cf">return</span> t

<span class="co">&quot;&quot;&quot;</span>
<span class="co">&gt;&gt;&gt; crible(10)</span>
<span class="co">[False, False, True, True, False, True, False, True, False, False, False]</span>
<span class="co">&gt;&gt;&gt; crible(1000).count(True)</span>
<span class="co">168 </span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-17" class="slide section level2">
<h1>Exo 17</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test_exo17():
    <span class="im">from</span> time <span class="im">import</span> time
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">17</span>):
        t0 <span class="op">=</span> time()
        nk <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>k
        pk <span class="op">=</span> crible(nk).count(<span class="va">True</span>)
        t1 <span class="op">=</span> time()
        t <span class="op">=</span> t1<span class="op">-</span>t0
        <span class="cf">if</span> k<span class="op">&gt;</span><span class="dv">10</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  pk={:4} | t(k)={:5.3f}| t(k)/t(k-1)={:5.3f}&#39;</span>.<span class="bu">format</span>(k,nk,pk,t,t<span class="op">/</span>tpreced))
        <span class="cf">else</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  pk={:4} |&#39;</span>
            <span class="co">&#39; t(k)={:5.3f}&#39;</span>.<span class="bu">format</span>(k,nk,pk,t))
        tpreced <span class="op">=</span> t</code></pre></div>
<p>On vérifie expérimentalemnt que la complexité en temps de l'algorithme du crible est quasiment linéaire (rapport très proche de 2)</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;</span>
<span class="co">In [29]: test_exo17()</span>
<span class="co">k=10 | nk= 1024 |  pk= 172 | t(k)=0.001</span>
<span class="co">k=11 | nk= 2048 |  pk= 309 | t(k)=0.001| t(k)/t(k-1)=2.085</span>
<span class="co">k=12 | nk= 4096 |  pk= 564 | t(k)=0.003| t(k)/t(k-1)=2.179</span>
<span class="co">k=13 | nk= 8192 |  pk=1028 | t(k)=0.003| t(k)/t(k-1)=0.985</span>
<span class="co">k=14 | nk=16384 |  pk=1900 | t(k)=0.003| t(k)/t(k-1)=1.324</span>
<span class="co">k=15 | nk=32768 |  pk=3512 | t(k)=0.007| t(k)/t(k-1)=2.074</span>
<span class="co">k=16 | nk=65536 |  pk=6542 | t(k)=0.015| t(k)/t(k-1)=2.108</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-18" class="slide section level2">
<h1>Exo 18</h1>
<p>Pour l'algorithme du crible l'espace mémoire est proportionnel à <span class="math inline">\(n\)</span> puisqu'on utilise une liste de taille <span class="math inline">\(n+1\)</span>.</p>
<p>Dans l'algorithme naif l'espace mémoire est constant puisqu'on utilise toujours le même nombre de variables (et pas de listes).</p>
<p>La complexité en temps est donc meilleure pour l'algorithme du crible mais sa complexité en espace est moins bonne.</p>
</div><div id="exo-19-project-euler-problem-10" class="slide section level2">
<h1>Exo 19 Project Euler problem 10</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> sum_of_prime(n):
    <span class="co">&#39;&#39;&#39;Project Euler problème 10 Summation of primes&#39;&#39;&#39;</span>
    t <span class="op">=</span> crible(n)
    s <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)):
        <span class="cf">if</span> t[k]:
            s <span class="op">+=</span> k
    <span class="cf">return</span> s

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [5]: sum_of_prime(2*10**6)</span>
<span class="co">Out[5]: 142913828922</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-20-project-euler-problem-21" class="slide section level2">
<h1>Exo 20 Project Euler problem 21</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> diviseurs(n):
    <span class="co">&#39;&#39;&#39;Retourne le tableau des diviseurs propres de n&#39;&#39;&#39;</span>
    tab <span class="op">=</span> [<span class="dv">1</span>]
    <span class="co">#boucle sur le plus petit diviseur</span>
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">int</span>(sqrt(n)) <span class="op">+</span> <span class="dv">1</span>):
        <span class="cf">if</span> n<span class="op">%</span>d <span class="op">==</span> <span class="dv">0</span>:
            tab.append(d)
            quotient <span class="op">=</span> n<span class="op">//</span>d
            <span class="cf">if</span> d <span class="op">!=</span> quotient:
                tab.append(quotient)
    <span class="cf">return</span> tab

<span class="kw">def</span> somme(tab):
    <span class="co">&#39;&#39;&#39;Retourne la somme des éléments d&#39;un tableau d&#39;entiers&#39;&#39;&#39;</span>
    s <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> element <span class="op">in</span> tab:
        s <span class="op">+=</span> element
    <span class="cf">return</span> s

<span class="kw">def</span> sum_of_amical(n):
    <span class="co">&#39;&#39;&#39;Retourne la somme des entiers amicaux entre 1 et n&#39;&#39;&#39;</span>
    <span class="co">#tableaux pour cribler les entiers amicaux</span>
    amicaux <span class="op">=</span> [<span class="va">False</span>]<span class="op">*</span>n
    <span class="co">#somme</span>
    s <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):
        <span class="co">#si n est déjà memoizé on passe son tour</span>
        <span class="cf">if</span> amicaux[n <span class="op">-</span> <span class="dv">1</span>]:
            <span class="cf">continue</span>
        sommediv <span class="op">=</span> somme(diviseurs(n))
        <span class="cf">if</span> sommediv <span class="op">!=</span> n <span class="op">and</span> somme(diviseurs(sommediv)) <span class="op">==</span> n:
            amicaux[n <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> amicaux[sommediv <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span>
            s <span class="op">+=</span> n <span class="op">+</span> sommediv
    <span class="cf">return</span> <span class="st">&#39;Somme des entiers amicaux &lt;= 10000 : </span><span class="sc">%d</span><span class="st">&#39;</span><span class="op">%</span>s

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [8]: sum_of_amical(10000)</span>
<span class="co">Out[8]: &#39;Somme des entiers amicaux &lt;= 10000 : 31626&#39;</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-21" class="slide section level2">
<h1>Exo 21</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> nbmoyen_diviseurs(n):
    <span class="co">&#39;&#39;&#39;Retourne le nombre moyen de diviseurs pour les entiers &lt;=n&#39;&#39;&#39;</span>
    crible <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">+</span> [<span class="dv">2</span>] <span class="op">*</span> (n<span class="dv">-1</span>)
    <span class="co">#k plus petit diviseur</span>
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">int</span>(math.sqrt(n)) <span class="op">+</span> <span class="dv">1</span>):
        <span class="co">#on crible tous les entiers divisible par k avec k + petit diviseur</span>
        crible[k<span class="op">*</span>k] <span class="op">+=</span> <span class="dv">1</span>
        <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(k<span class="dv">+1</span>, n<span class="op">//</span>k <span class="op">+</span> <span class="dv">1</span>):
            crible[j<span class="op">*</span>k] <span class="op">+=</span> <span class="dv">2</span>
    <span class="cf">return</span> crible, <span class="bu">sum</span>(crible)<span class="op">/</span>n

<span class="kw">def</span> test_exo21():
    <span class="im">from</span> time <span class="im">import</span> time
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">17</span>):
        t0 <span class="op">=</span> time()
        nk <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>k
        <span class="co">#nombre moyen de diviseurs</span>
        mk <span class="op">=</span> nbmoyen_diviseurs(nk)[<span class="dv">1</span>]
        t1 <span class="op">=</span> time()
        t <span class="op">=</span> t1<span class="op">-</span>t0
        <span class="cf">if</span> k<span class="op">&gt;</span><span class="dv">10</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  mk={:6.3f} | log(nk) = {:6.3f} |&#39;</span>
            <span class="co">&#39; t(k)={:5.3f}| t(k)/t(k-1)={:5.3f}&#39;</span>.<span class="bu">format</span>(k, nk, mk,
             math.log(nk),t,t<span class="op">/</span>tpreced))
        <span class="cf">else</span>:
            <span class="bu">print</span>(<span class="st">&#39;k={:2} | nk={:5} |  mk={:6.3f} | log(nk) = {:6.3f} |&#39;</span>
            <span class="co">&#39; t(k)={:5.3f}| &#39;</span>.<span class="bu">format</span>(k,nk,mk, math.log(nk),t))
        tpreced <span class="op">=</span> t
        
<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [86]: test_exo21()</span>
<span class="co">k=10 | nk= 1024 |  mk= 7.092 | log(nk) =  6.931 | t(k)=0.000| </span>
<span class="co">k=11 | nk= 2048 |  mk= 7.782 | log(nk) =  7.625 | t(k)=0.001| t(k)/t(k-1)=2.257</span>
<span class="co">k=12 | nk= 4096 |  mk= 8.477 | log(nk) =  8.318 | t(k)=0.002| t(k)/t(k-1)=2.445</span>
<span class="co">k=13 | nk= 8192 |  mk= 9.168 | log(nk) =  9.011 | t(k)=0.004| t(k)/t(k-1)=2.020</span>
<span class="co">k=14 | nk=16384 |  mk= 9.860 | log(nk) =  9.704 | t(k)=0.012| t(k)/t(k-1)=3.219</span>
<span class="co">k=15 | nk=32768 |  mk=10.553 | log(nk) = 10.397 | t(k)=0.018| t(k)/t(k-1)=1.585</span>
<span class="co">k=16 | nk=65536 |  mk=11.245 | log(nk) = 11.090 | t(k)=0.040| t(k)/t(k-1)=2.186</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
<p>Effectivement le nombre moyen de diviseurs pour les entiers majorés par <span class="math inline">\(n\)</span> semble équivalent à <span class="math inline">\(\log(n)\)</span>.</p>
</div><div id="exo-22-project-euler-problem-124-ordered-radicals" class="slide section level2">
<h1>Exo 22 Project Euler problem 124 Ordered radicals</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> rad(n):
    radicaux <span class="op">=</span> [[i, <span class="dv">1</span>] <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="dv">+1</span>)]
    <span class="co">#boucle sur tous les diviseurs premiers possibles &lt;= n</span>
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):
        <span class="co">#si k est premier (un seul diviseur premier lui-meme)</span>
        <span class="cf">if</span> radicaux[k<span class="dv">-1</span>][<span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:
            <span class="co">#boucle sur tous les multiples possibles de k</span>
            <span class="co">#à l&#39;inverse du crible d&#39;Eratosthene on commence à 1</span>
            <span class="co">#car le radical d&#39;un entier premier est lui-meme</span>
            <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">//</span>k <span class="op">+</span> <span class="dv">1</span>):
                radicaux[j<span class="op">*</span>k <span class="op">-</span> <span class="dv">1</span>][<span class="dv">1</span>] <span class="op">*=</span> k
    radicaux.sort(key<span class="op">=</span><span class="kw">lambda</span> t : t[<span class="dv">1</span>])
    <span class="cf">return</span> radicaux

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [10]: t = rad(100000)</span>
<span class="co">In [11]: t[9999]</span>
<span class="co">Out[11]: [21417, 1947]</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div><div id="exo-23" class="slide section level2">
<h1>Exo 23</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> rotation(n, exposantmax):
    <span class="co">&#39;&#39;&#39;rotation d&#39;un entier n,  10**(exposantmax) &lt;= n &lt; 10**(exposantmax+1)&#39;&#39;&#39;</span>
    <span class="cf">return</span> (n<span class="op">%</span><span class="dv">10</span>)<span class="op">*</span><span class="dv">10</span><span class="op">**</span>exposantmax <span class="op">+</span> n<span class="op">//</span><span class="dv">10</span>

<span class="kw">def</span> est_premiercirculaire(n, uncrible):
    ecriture_decimale <span class="op">=</span> <span class="bu">str</span>(n)
    exposantmax <span class="op">=</span> <span class="bu">len</span>(ecriture_decimale) <span class="op">-</span> <span class="dv">1</span>
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(exposantmax):
        n <span class="op">=</span> rotation(n, exposantmax)
        <span class="cf">if</span> <span class="op">not</span> uncrible[n]:
            <span class="cf">return</span> <span class="va">False</span>
    <span class="cf">return</span> <span class="va">True</span>

<span class="kw">def</span> circular_primes(n):
    <span class="co">&#39;&#39;&#39;Retourne le nombre de premiers circulaires &lt;= n&#39;&#39;&#39;</span>
    <span class="co">#crible d&#39;Eratosthene des entiers premiers &lt;= n</span>
    moncrible <span class="op">=</span> crible(n)
    compteur <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> k <span class="op">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):
        <span class="cf">if</span>  moncrible[k]:
            <span class="cf">if</span> est_premiercirculaire(k, moncrible):
                compteur <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> compteur

<span class="co">&quot;&quot;&quot;</span>
<span class="co">In [14]: circular_primes(10**6)</span>
<span class="co">Out[14]: 55</span>
<span class="co">&quot;&quot;&quot;</span></code></pre></div>
</div>
</body>
</html>
